{"version":3,"file":"data-experience.umd.min.6641.js","mappings":"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","sources":["webpack://data-experience/./node_modules/crossfilter2/src/array.js","webpack://data-experience/./node_modules/crossfilter2/src/filter.js","webpack://data-experience/./node_modules/crossfilter2/src/identity.js","webpack://data-experience/./node_modules/crossfilter2/src/null.js","webpack://data-experience/./node_modules/crossfilter2/src/zero.js","webpack://data-experience/./node_modules/crossfilter2/src/heap.js","webpack://data-experience/./node_modules/crossfilter2/src/heapselect.js","webpack://data-experience/./node_modules/crossfilter2/src/bisect.js","webpack://data-experience/./node_modules/crossfilter2/src/permute.js","webpack://data-experience/./node_modules/crossfilter2/src/reduce.js","webpack://data-experience/./node_modules/@ranfdev/deepobj/dist/deepobj.m.js","webpack://data-experience/./node_modules/crossfilter2/src/result.js","webpack://data-experience/./node_modules/crossfilter2/src/index.js"],"sourcesContent":["let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask = (mask & zero) >>> 0;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n\n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n\n    function currentFilter() {\n      return filterValue;\n    }\n\n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n            groupIndex = groupIndex.slice(0, j);\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n"],"names":["array8","arrayUntyped","array16","array32","arrayLengthen","arrayLengthenUntyped","arrayWiden","arrayWidenUntyped","n","array","Array","i","length","width","Error","bitarray","this","subarrays","masks","Uint8Array","Uint16Array","Uint32Array","copy","constructor","set","prototype","lengthen","len","add","m","w","one","offset","dest","src","truncate","j","zero","zeroExcept","zeroExceptMask","mask","only","onlyExcept","onlyOffset","onlyOne","filterExact","bisect","value","values","left","right","filterRange","range","min","max","filterAll","d","heap_by","f","heap","a","lo","hi","sift","sort","t","child","x","h","identity","by","heapselect_by","heapselect","k","queue","Math","bisect_by","bisectLeft","mid","bisectRight","index","deep","JSON","parse","stringify","reduceIncrement","p","reduceDecrement","reduceAdd","v","reduceSubtract","e","r","split","splice","get","obj","prop","call","reg","path","replace","REMOVED_INDEX","crossfilter","permute","filters","remove","removeData","dimension","groupAll","size","all","allFiltered","onChange","isElementFiltered","data","filterListeners","dataListeners","removeDataListeners","callbacks","newData","n0","n1","concat","forEach","l","triggerOnChange","predicate","newIndex","removed","usePred","shouldRemove","index1","index2","push","index3","index4","maskForDimensions","dimensions","id","ignore_dimensions","iterable","accessorPath","result","newValues","iterablesIndexCount","iterablesIndexFilterStatus","refilterFunction","filterValue","filterValuePresent","filter","filterFunction","currentFilter","hasCurrentFilter","top","bottom","group","dispose","accessor","iterablesEmptyRows","sortRange","cr_range","A","B","b","refilter","indexListeners","dimensionGroups","lo0","hi0","unshift","preAdd","postAdd","tmp","newIterablesIndexCount","newIterablesIndexFilterStatus","i0","cr_index","unsortedIndex","sortMap","map","bounds","lo1","hi1","old_n0","oldValues","oldIndex","oldIterablesIndexFilterStatus","i1","oldiiclength","index5","reIndex","slice","oldDataIndex","filterIndexBounds","filterIndexFunction","added","valueIndexAdded","valueIndexRemoved","newAdded","newRemoved","isArray","undefined","indexLength","top_offset","toSkip","bottom_offset","key","reduce","reduceCount","reduceSum","order","orderNatural","groups","groupIndex","select","reduceRemove","reduceInitial","n0old","groupWidth","groupCapacity","capacity","update","reset","resetNeeded","g0","x0","x1","g","oldGroups","initial","k0","groupIncrement","indexOf","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","filterOffset","notFilter","valueOf","arguments","log","reduceValue","cb","console","warn","eventName"],"sourceRoot":""}